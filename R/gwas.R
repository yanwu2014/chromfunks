## Functions for computing the enrichment of genomic regions (i.e. GWAS-linked SNPs)
## with cluster specific diff accessible sites


#' Calculate p-values linking phenotypes to clusters using permutation testing
#'
#' @param pheno.blocks A list of genomic regions for each GWAS phenotype in granges format
#' @param top_diff_peaks A list of top accessible sites for each cluster in granges format
#' @param background_peaks A granges of background accessible peaks to sample from
#' @param n.rand Number of permutations
#' @param n.cores Number of cores for parallel processing
#' @param score.col Whether or not to use z-scores or just the number of overlapping regions
#'
#' @return A matrix of empirical p-values for each phenotype/cluster enrichment test
#' @import snow
#' @import GenomicRanges
#' @import abind
#' @export
#'
cluster_pheno_pvals <- function(pheno.blocks, top_diff_peaks, background_peaks,
                                n.rand = 1e4, n.cores = 8, z.score = T) {
  scores <- cluster_pheno_scores(pheno.blocks, top_diff_peaks, z.score)

  n_diff_peaks <- sapply(top_diff_peaks, length)
  cl <- snow::makeCluster(n.cores, type = "SOCK")
  invisible(snow::parLapply(cl, 1:n.cores, function(i) library(GenomicRanges)))
  snow::clusterExport(cl, c("background_peaks", "cluster_pheno_scores", "n_diff_peaks",
                            "pheno.blocks", "z.score"),
                      envir = environment())
  rand.scores <- snow::parLapply(cl, 1:n.rand, function(i) {
    idx.draw <- 1:length(background_peaks)
    rand_diff_peaks <- lapply(n_diff_peaks, function(n) {
      idx.sample <- sample(idx.draw, size = n)
      background_peaks[idx.sample]
    })
    cluster_pheno_scores(pheno.blocks, rand_diff_peaks, z.score)
  })
  on.exit(snow::stopCluster(cl))
  rand.scores <- abind::abind(rand.scores, along = 3)

  t(calc_emp_pvals(scores, rand.scores))
}



#' Intersect phenotype-linked LD blocks with peaks
#'
#' @param pheno.blocks A list of genomic regions for each GWAS phenotype in granges format
#' @param top_diff_peaks A list of top accessible sites for each cluster in granges format
#' @param z.score Whether or not to use z-scores or just the number of overlapping regions
#'
#' @return A matrix of overlap scores for each phenotype/cluster combination
#' @import GenomicRanges
#' @export
#'
cluster_pheno_scores <- function(pheno.blocks, top_diff_peaks, z.score = T) {
  sapply(pheno.blocks, function(blocks) {
    sapply(top_diff_peaks, function(gr) {
      hits <- suppressWarnings(GenomicRanges::findOverlaps(blocks, gr, ignore.strand = T))
      blocks.ix <- unique(hits@from)
      if (z.score) {
        return(sum(blocks[blocks.ix]$z))
      } else {
        return(length(blocks.ix))
      }
    })
  })
}



#' Extracts significant mutations for each cluster
#'
#' @param pheno.blocks A list of genomic regions for each GWAS phenotype in granges format
#' @param top_diff_peaks A list of top accessible sites for each cluster in granges format
#'
#' @return A list of lists for each phenotype/cluster combination with
#' @import GenomicRanges
#' @export
#'
extract_sig_mutations <- function(pheno.blocks, top_diff_peaks) {
  celltype_mutations <- lapply(pheno.blocks, function(blocks) {
    snps <- lapply(top_diff_peaks, function(gr) {
      hits <- suppressWarnings(GenomicRanges::findOverlaps(blocks, gr, ignore.strand = T))
      snp2peak <- tapply(names(gr[hits@to]), hits@from, function(x) paste(x, collapse = ";"))
      blocks <- blocks[as.integer(names(snp2peak))]
      if (length(blocks) > 0) {
        df <- data.frame(chr = as.character(seqnames(blocks)), start = start(blocks),
                         end = end(blocks), snp = blocks$snp, z = blocks$z,
                         peaks = snp2peak)
      } else {
        df <- NULL
      }
      df
    })
    snps[!is.null(snps)]
  })
}




#' Compute blocks for each GWAS phenotype by finding the tag snp for in each LD block and extending by the buffer size
#'
#' @param sig.pheno.snps List of SNPs for each GWAS phenotype that pass the p-value threshold
#' @param snp.data Dataframe of SNP genomic location and other info generated by get_snp_data
#' @param ld_blocks Granges of LD blocks
#' @param chr.lengths Dataframe of chromosome lengths
#' @param buffer.size Buffer size around each tag snp
#' @param max.block.size Maximum size of each block (larger blocks will be split)
#' @param max.blocks Maximum number of LD blocks for each phenotype
#'
#' @return List of blocks for each phenotype defined by the top tag snp for that block
#' @import GenomicRanges
#' @export
#'
get_pheno_blocks <- function(sig.pheno.snps, snp.data, ld_blocks, chr.lengths, buffer.size = 2e4,
                             max.block.size = Inf, max.blocks = Inf) {

  ## Map SNPs to 1000 genomes LD blocks
  snp.granges <- GenomicRanges::makeGRangesFromDataFrame(snp.data, keep.extra.columns = T)

  if (is.null(ld_blocks)) {
    snp.granges.extended <- GenomicRanges::extend_gr(snp.granges, buffer = buffer.size,
                                                     chr.lengths = chr.lengths)
    snp.granges.merged <- reduce(snp.granges.extended, with.revmap = T)
    block2snp <- lapply(1:length(snp.granges.merged), function(i) {
      jj <- snp.granges.merged[i]$revmap[[1]]
      snp.granges[jj]
    })
  } else {
    block.snp.idx <- GenomicRanges::findOverlaps(ld_blocks, snp.granges)
    block.snp.idx <- as.data.frame(block.snp.idx)
    block2snp <- lapply(unique(block.snp.idx$queryHits), function(i) {
      jj <- subset(block.snp.idx, queryHits == i)$subjectHits
      snp.granges[jj]
    })
  }
  block2snp <- get_block_boundaries(block2snp, chr.lengths, buffer.size = buffer.size)

  ## Split blocks
  blocks.granges <- peak2granges(names(block2snp))
  blocks.split <- names(blocks.granges)[width(blocks.granges) > max.block.size]
  for (bl in blocks.split) {
    bl.snps.gr <- block2snp[[bl]]; block2snp[[bl]] <- NULL;
    block2snp <- c(block2snp, split_block(bl.snps.gr, chr.lengths, buffer.size))
  }
  blocks.granges <- peak2granges(names(block2snp))

  print(paste0("Median block width: ", median(width(blocks.granges))))
  print(paste0("Mean block width: ", mean(width(blocks.granges))))

  ## Map each SNP to a block
  snp2block <- unlist(invertList(lapply(block2snp, function(x) names(x))))

  ## Compile blocks for each phenotype
  pheno.blocks <- lapply(sig.pheno.snps, function(z) {
    ## Keep the most significant tag snp for each LD block
    block.z <- z[names(z) %in% names(snp2block)]
    block.names <- factor(snp2block[names(block.z)])
    block.tag.z <- z[tapply(block.z, block.names, function(x) names(x)[which.max(x)])]

    single.tag.z <- z[!names(z) %in% names(snp2block)]
    single.tag.z <- single.tag.z[names(single.tag.z) %in% snp.data$snp]
    stopifnot(length(intersect(names(single.tag.z), names(block.tag.z))) == 0)

    ## Extend SNP boundaries and keep the most significant SNP for any overlapping SNPs
    tag.snps.z <- c(block.tag.z, single.tag.z)
    tag.snps.gr <- get_snp_gr(tag.snps.z, snp.data, buffer.size, chr.lengths)
    tag.snps.gr.merged <- reduce(tag.snps.gr, with.revmap = T)

    ii <- sapply(tag.snps.gr.merged$revmap, function(ix) ix[which.max(tag.snps.gr[ix]$z)])
    tag.snps.gr.merged$z <- tag.snps.gr[ii]$z
    tag.snps.gr.merged$snp <- tag.snps.gr[ii]$snp

    unique.snp.z <- tag.snps.gr.merged$z; names(unique.snp.z) <- tag.snps.gr.merged$snp;
    unique.snps.gr <- get_snp_gr(unique.snp.z, snp.data, buffer.size, chr.lengths)

    unique.snps.gr <- unique.snps.gr[order(unique.snps.gr$z, decreasing = T),]
    return(unique.snps.gr[1:min(length(unique.snps.gr), max.blocks)])
  })

  pheno.blocks
}


#' Parse LD blocks from file
#'
#' @param file.path Path to LD blocks file
#'
#' @return List of snps contained within each LD block
#' @export
#'
parse_ld_blocks <- function(file.path) {
  ld.table <- read.table(file.path, header = F, sep = "\t", stringsAsFactors = F)
  block.names <- unique(ld.table[[1]])
  block2snp <- list()
  for (i in 1:nrow(ld.table)) {
    snps <- strsplit(ld.table[i,2], split = ";")[[1]]
    block2snp[[ld.table[i,1]]] <- snps
  }

  block2snp
}


#' Parse munged sumstats files (same format as input to LDSC)
#'
#' @param file.path Path to sumstats file
#' @param p.cutoff P-value cutoff for keeping a SNP
#'
#' @return Vector of z-scores for all SNPs in the sumstats file
#' @export
#'
parse_sumstats <- function(file.path, p.cutoff = 1e-3) {
  sumstats.table <- read.table(file.path, header = T, sep = "\t", stringsAsFactors = F)
  sumstats.table <- subset(sumstats.table, Z > qnorm(p.cutoff, lower.tail = F))
  sumstats.table <- sumstats.table[order(sumstats.table$Z, decreasing = T),]

  snp.z <- sumstats.table$Z; names(snp.z) <- sumstats.table$SNP;
  return(snp.z)
}



#' Parse files downloaded from the GRASP database
#'
#' @param file.path Path to sumstats file
#'
#' @return Vector of z-scores for all SNPs in the sumstats file
#' @export
#'
parse_grasp <- function(file.path) {
  snp.table <- read.table(file.path, header = T, sep = ",", stringsAsFactors = F)
  snp.table <- snp.table[order(snp.table$Pvalue),]

  snp.p <- snp.table$Pvalue
  snp.z <- qnorm(snp.p, lower.tail = F)
  names(snp.z) <- snp.table[["Snp.Id"]]
  return(snp.z)
}



#' Filter SNPs by p-value
#'
#' @param pheno.snp.list List of z-scores for the SNPs in each phenotype
#' @param p.cutoff P-value cutoff
#' @param max.snps Max number of SNPs for each phenotype
#' @param min.snps Phenotypes with fewer than this number of snps passing filter will be removed
#'
#' @return List of filtered z-scores for the SNPs in each phenotype
#' @export
#'
filter_snps <- function(pheno.snp.list, p.cutoff, max.snps = Inf, min.snps = 1) {
  z.cutoff <- qnorm(p.cutoff, lower.tail = F)
  sig.snp.list <- lapply(pheno.snp.list, function(snp.z) {
    snp.z <- snp.z[snp.z > z.cutoff]
    snp.z[1:min(max.snps, length(snp.z))]
  })
  sig.snp.list[sapply(sig.snp.list, length) > min.snps]
}



#' Download SNP data from dbSNP using biomaRt
#'
#' @param snps Vector of SNP rsIDs
#'
#' @return Dataframe with the genomic location of each SNP (in hg38 coordinates)
#'
#' @import biomaRt
#' @export
#'
get_snp_data <- function(snps) {
  require(biomaRt)
  snp_mart = useMart("ENSEMBL_MART_SNP", dataset = "hsapiens_snp")

  snp_attributes = c("refsnp_id", "chr_name", "chrom_start")
  snp.df <- getBM(attributes = snp_attributes, filters = "snp_filter",
                  values = snps, mart = snp_mart)
  colnames(snp.df) <- c("snp", "chr", "start")
  snp.df$end <- snp.df$start + 1
  snp.df$chr <- paste0("chr", snp.df$chr)
  snp.df <- snp.df[!duplicated(snp.df$snp),]
  rownames(snp.df) <- snp.df$snp
  snp.df[,c("chr", "start", "end", "snp")]
}


#' Parse bed files
#' @param dir.path Path to directory with bed files
#'
#' @return List of genomic ranges, one for each file in the directory
#'
#' @import ChIPseeker
#' @import GenomicRanges
#' @export
#'
parse_bed_directory <- function(dir.path) {
  require(ChIPseeker)
  bed.files <- list.files(path = dir.path, pattern = ".bed")
  peaks_list <- lapply(bed.files, function(fi) {
    fi <- paste0(dir.path, "/", fi)
    gr <- readPeakFile(fi)
    names(gr) <- paste(seqnames(gr), start(gr), end(gr), sep = "_")
    gr
  })
  names(peaks_list) <- bed.files
  peaks_list
}


## Helper functions


## Calculate empirical p-values
calc_emp_pvals <- function(cfs, cfs.rand) {
  p.vals <- matrix(1, nrow(cfs), ncol(cfs))
  colnames(p.vals) <- colnames(cfs)
  rownames(p.vals) <- rownames(cfs)
  for (i in 1:nrow(cfs)) {
    for (j in 1:ncol(cfs)) {
      v <- sort(na.omit(cfs.rand[i,j,]))
      b <- cfs[i,j]
      p.vals[i,j] <- (sum(v >= b) + 1)/(length(v) + 1)
    }
  }
  return(p.vals)
}


## Split LD block
split_block <- function(snp.gr, chr.lengths, buffer.size = 5e4) {
  snp.gr <- extend_gr(snp.gr, buffer = buffer.size, chr.lengths = chr.lengths)
  snp.gr.merged <- reduce(snp.gr, with.revmap = T)

  new.blocks.list <- lapply(snp.gr.merged$revmap, function(ix) snp.gr[ix])
  get_block_boundaries(new.blocks.list, chr.lengths, buffer.size = buffer.size)
}


## Define block boundaries based off of significant SNPs
get_block_boundaries <- function(blocks.list, chr.lengths, buffer.size = 5e4) {
  regions <- sapply(blocks.list, function(gr) {
    chr <- as.character(seqnames(gr))[[1]]
    stopifnot(all(as.character(seqnames(gr)) == chr))

    region.start <- max(min(start(gr)) - buffer.size, 1)
    region.end <- min(max(end(gr)) + buffer.size, chr.lengths[chr,2])
    paste0(chr, ":", region.start, "-", region.end)
  })
  names(blocks.list) <- regions
  blocks.list
}


## Extend SNP coordinates
get_snp_gr <- function(snp.z, snp.data, buffer.size, chr.lengths) {
  snps <- names(snp.z)
  chr <- snp.data[snps, "chr"]
  pos <- snp.data[snps, "start"]

  start <- pmax(1, pos - buffer.size)
  end <- pmin(chr.lengths[chr, 2], pos + buffer.size)

  regions <- paste0(chr, ":", start, "-", end)
  peak2granges(regions, metadata.df = data.frame(z = snp.z, snp = names(snp.z)))
}
